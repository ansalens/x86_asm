#  Compiling a C Program: Behind the Scenes

- Compilation turns our source code into __machine code__ which can be __executed__ by our machine.
- This is the process of compiling a C program:

![compile](scrs/compilation.png)


- We can get each temporary file which is generated by `gcc` during compilation process with:
```sh
$ gcc -Wall -save-temps prog.c -o prog
```

- Notice that we get all intermediate files: `prog.i  prog.o  prog.s` 

## Preprocessing

- Preprocessing is a first step in this process.
- __It removes comments, expands macros, expands included files, and involves conditional compilation.__
- Restrict `gcc` to output only pre-processed file:

```sh
$ gcc -E prog.c -o prog.i
```

## Compiling

- Next step is compiling `prog.i` which we got from preprocessing step and producing __assembly equivalent `prog.s`__.
- This is a step where __in-line assembly__ is processed.

- Use `gcc` to generate only assembly equivalent code:

```sh
$ gcc -S prog.c -fverbose-asm -o prog.s
```

## Assembling

- This step takes `prog.s` and turns it into __object file__ `prog.o` which will contain __machine code__.
- __No external functions (such as printf) are resolved yet__.
- This is first step in generating __ELF__ file.
- Use `gcc` to preprocess, compile and assemble but don't link:

```sh
gcc -c prog.c -o prog.o
```


## Linking

- Final step in compilation process.
- Linker knows __where every function is__ and __resolves__ them (meaning functions like printf can be called).
- It also adds some extra code which is needed for __starting and ending our program__.
- Because it adds some extra code, size of final binary increases.
- __All these steps are done automatically via `gcc`.__


---

#### Sources 

1. https://www.geeksforgeeks.org/compiling-a-c-program-behind-the-scenes/
2. https://stackoverflow.com/questions/8527743/running-gccs-steps-manually-compiling-assembling-linking
